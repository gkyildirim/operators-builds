{
  "version": 3,
  "sources": ["../../../../modules/operators/src/concat_latest_from.ts", "../../../../modules/operators/src/map-response.ts", "../../../../modules/operators/src/tap-response.ts"],
  "sourcesContent": ["import {\n  Observable,\n  ObservableInput,\n  of,\n  ObservedValueOf,\n  OperatorFunction,\n} from 'rxjs';\nimport { concatMap, withLatestFrom } from 'rxjs/operators';\n\n// The array overload is needed first because we want to maintain the proper order in the resulting tuple\nexport function concatLatestFrom<T extends Observable<unknown>[], V>(\n  observablesFactory: (value: V) => [...T]\n): OperatorFunction<V, [V, ...{ [i in keyof T]: ObservedValueOf<T[i]> }]>;\nexport function concatLatestFrom<T extends Observable<unknown>, V>(\n  observableFactory: (value: V) => T\n): OperatorFunction<V, [V, ObservedValueOf<T>]>;\n/**\n * `concatLatestFrom` combines the source value\n * and the last available value from a lazily evaluated Observable\n * in a new array\n *\n * @usageNotes\n *\n * Select the active customer from the NgRx Store\n *\n * ```ts\n * import { concatLatestFrom } from '@ngrx/operators';\n * import * as fromCustomers from '../customers';\n *\n * this.actions$.pipe(\n *  concatLatestFrom(() => this.store.select(fromCustomers.selectActiveCustomer))\n * )\n * ```\n *\n * Select a customer from the NgRx Store by its id that is available on the action\n *\n * ```ts\n * import { concatLatestFrom } from '@ngrx/operators';\n * import * fromCustomers from '../customers';\n *\n * this.actions$.pipe(\n *  concatLatestFrom((action) => this.store.select(fromCustomers.selectCustomer(action.customerId)))\n * )\n * ```\n */\nexport function concatLatestFrom<\n  T extends ObservableInput<unknown>[] | ObservableInput<unknown>,\n  V,\n  R = [\n    V,\n    ...(T extends ObservableInput<unknown>[]\n      ? { [i in keyof T]: ObservedValueOf<T[i]> }\n      : [ObservedValueOf<T>])\n  ]\n>(observablesFactory: (value: V) => T): OperatorFunction<V, R> {\n  return concatMap((value) => {\n    const observables = observablesFactory(value);\n    const observablesAsArray = Array.isArray(observables)\n      ? observables\n      : [observables];\n    return of(value).pipe(\n      withLatestFrom(...observablesAsArray)\n    ) as unknown as Observable<R>;\n  });\n}\n", "import { Observable, of } from 'rxjs';\nimport { catchError, map } from 'rxjs/operators';\n\ntype MapResponseObserver<T, E, R1, R2> = {\n  next: (value: T) => R1;\n  error: (error: E) => R2;\n};\n\n/**\n * `mapResponse` is a map operator with included error handling.\n * It is similar to `tapResponse`, but allows to map the response as well.\n *\n * The main use case is for NgRx Effects which requires an action to be dispatched.\n *\n * @usageNotes\n * ```ts\n * export const loadAllUsers = createEffect((\n *   actions$ = inject(Actions),\n *   usersService = inject(UsersService)\n * ) => {\n *   return actions$.pipe(\n *     ofType(UsersPageActions.opened),\n *     exhaustMap(() => {\n *       return usersService.getAll().pipe(\n *         mapResponse({\n *           next: (users) => UsersApiActions.usersLoadedSuccess({ users }),\n *           error: (error) => UsersApiActions.usersLoadedFailure({ error }),\n *         })\n *       );\n *     })\n *   );\n * });\n * ```\n */\nexport function mapResponse<T, E, R1, R2>(\n  observer: MapResponseObserver<T, E, R1, R2>\n): (source$: Observable<T>) => Observable<R1 | R2> {\n  return (source$) =>\n    source$.pipe(\n      map((value) => observer.next(value)),\n      catchError((error) => of(observer.error(error)))\n    );\n}\n", "import { EMPTY, Observable } from 'rxjs';\nimport { catchError, finalize, tap } from 'rxjs/operators';\n\ntype TapResponseObserver<T, E> = {\n  next: (value: T) => void;\n  error: (error: E) => void;\n  complete?: () => void;\n  finalize?: () => void;\n};\n\nexport function tapResponse<T, E = unknown>(\n  observer: TapResponseObserver<T, E>\n): (source$: Observable<T>) => Observable<T>;\nexport function tapResponse<T, E = unknown>(\n  next: (value: T) => void,\n  error: (error: E) => void,\n  complete?: () => void\n): (source$: Observable<T>) => Observable<T>;\n/**\n * Handles the response in ComponentStore effects in a safe way, without\n * additional boilerplate. It enforces that the error case is handled and\n * that the effect would still be running should an error occur.\n *\n * Takes optional callbacks for `complete` and `finalize`.\n *\n * @usageNotes\n *\n * ```ts\n * readonly dismissAlert = this.effect<Alert>((alert$) => {\n *   return alert$.pipe(\n *     concatMap(\n *       (alert) => this.alertsService.dismissAlert(alert).pipe(\n *         tapResponse(\n *           (dismissedAlert) => this.alertDismissed(dismissedAlert),\n *           (error: { message: string }) => this.logError(error.message)\n *         )\n *       )\n *     )\n *   );\n * });\n *\n * readonly loadUsers = this.effect<void>((trigger$) => {\n *   return trigger$.pipe(\n *     tap(() => this.patchState({ loading: true })),\n *     exhaustMap(() =>\n *       this.usersService.getAll().pipe(\n *         tapResponse({\n *           next: (users) => this.patchState({ users }),\n *           error: (error: HttpErrorResponse) => this.logError(error.message),\n *           finalize: () => this.patchState({ loading: false }),\n *         })\n *       )\n *     )\n *   );\n * });\n * ```\n */\nexport function tapResponse<T, E>(\n  observerOrNext: TapResponseObserver<T, E> | ((value: T) => void),\n  error?: (error: E) => void,\n  complete?: () => void\n): (source$: Observable<T>) => Observable<T> {\n  const observer: TapResponseObserver<T, E> =\n    typeof observerOrNext === 'function'\n      ? {\n          next: observerOrNext,\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          error: error!,\n          complete,\n        }\n      : observerOrNext;\n\n  return (source) =>\n    source.pipe(\n      tap({ next: observer.next, complete: observer.complete }),\n      catchError((error) => {\n        observer.error(error);\n        return EMPTY;\n      }),\n      observer.finalize ? finalize(observer.finalize) : (source$) => source$\n    );\n}\n"],
  "mappings": ";AAAA,SAGE,UAGK;AACP,SAAS,WAAW,sBAAsB;AAsCpC,SAAU,iBASd,oBAAmC;AACnC,SAAO,UAAU,CAAC,UAAS;AACzB,UAAM,cAAc,mBAAmB,KAAK;AAC5C,UAAM,qBAAqB,MAAM,QAAQ,WAAW,IAChD,cACA,CAAC,WAAW;AAChB,WAAO,GAAG,KAAK,EAAE,KACf,eAAe,GAAG,kBAAkB,CAAC;EAEzC,CAAC;AACH;;;AChEA,SAAqB,MAAAA,WAAU;AAC/B,SAAS,YAAY,WAAW;AAiC1B,SAAU,YACd,UAA2C;AAE3C,SAAO,CAAC,YACN,QAAQ,KACN,IAAI,CAAC,UAAU,SAAS,KAAK,KAAK,CAAC,GACnC,WAAW,CAAC,UAAUA,IAAG,SAAS,MAAM,KAAK,CAAC,CAAC,CAAC;AAEtD;;;AC1CA,SAAS,aAAyB;AAClC,SAAS,cAAAC,aAAY,UAAU,WAAW;AAwDpC,SAAU,YACd,gBACA,OACA,UAAqB;AAErB,QAAM,WACJ,OAAO,mBAAmB,aACtB;IACE,MAAM;;IAEN;IACA;MAEF;AAEN,SAAO,CAAC,WACN,OAAO,KACL,IAAI,EAAE,MAAM,SAAS,MAAM,UAAU,SAAS,SAAQ,CAAE,GACxDA,YAAW,CAACC,WAAS;AACnB,aAAS,MAAMA,MAAK;AACpB,WAAO;EACT,CAAC,GACD,SAAS,WAAW,SAAS,SAAS,QAAQ,IAAI,CAAC,YAAY,OAAO;AAE5E;",
  "names": ["of", "catchError", "error"]
}
